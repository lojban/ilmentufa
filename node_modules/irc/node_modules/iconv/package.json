{
  "name": "iconv",
  "main": "./lib/iconv",
  "version": "2.1.11",
  "description": "Text recoding in JavaScript for fun and profit!",
  "homepage": "https://github.com/bnoordhuis/node-iconv",
  "repository": {
    "type": "git",
    "url": "git://github.com/bnoordhuis/node-iconv.git"
  },
  "author": {
    "name": "Ben Noordhuis",
    "email": "info@bnoordhuis.nl"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "license": "ISC",
  "readmeFilename": "README.md",
  "dependencies": {
    "nan": "~2.0.4"
  },
  "devDependencies": {
    "tap": "~0.4.8"
  },
  "scripts": {
    "test": "tap test/test-*.js",
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "# node-iconv\n\nText recoding in JavaScript for fun and profit!\n\n## Supported encodings\n\n    European languages\n        ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16},\n        KOI8-R, KOI8-U, KOI8-RU,\n        CP{437,737,775,850,852,853,855,857,858,860,861,863,865,866,869}\n        CP{1125,1250,1251,1252,1253,1254,1257}\n        Mac{Roman,CentralEurope,Iceland,Croatian,Romania},\n        Mac{Cyrillic,Ukraine,Greek,Turkish},\n        Macintosh\n    Semitic languages\n        ISO-8859-{6,8}, CP{1255,1256}, CP862, CP864, Mac{Hebrew,Arabic}\n    Japanese\n        EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2, ISO-2022-JP-1\n        EUC-JISX0213, Shift_JISX0213, ISO-2022-JP-3\n    Chinese\n        EUC-CN, HZ, GBK, CP936, GB18030, EUC-TW, BIG5, CP950, BIG5-HKSCS,\n        BIG5-HKSCS:2004, BIG5-HKSCS:2001, BIG5-HKSCS:1999, ISO-2022-CN,\n        ISO-2022-CN-EXT, BIG5-2003 (experimental)\n    Korean\n        EUC-KR, CP949, ISO-2022-KR, JOHAB\n    Turkmen\n        TDS565\n    Armenian\n        ARMSCII-8\n    Georgian\n        Georgian-Academy, Georgian-PS\n    Tajik\n        KOI8-T\n    Kazakh\n        PT154, RK1048\n    Thai\n        ISO-8859-11, TIS-620, CP874, MacThai\n    Laotian\n        MuleLao-1, CP1133\n    Vietnamese\n        VISCII, TCVN, CP1258\n    Platform specifics\n        HP-ROMAN8, NEXTSTEP, ATARIST, RISCOS-LATIN1\n    Full Unicode\n        UTF-8\n        UCS-2, UCS-2BE, UCS-2LE\n        UCS-4, UCS-4BE, UCS-4LE\n        UTF-16, UTF-16BE, UTF-16LE\n        UTF-32, UTF-32BE, UTF-32LE\n        UTF-7\n        C99, JAVA\n    Full Unicode, in terms of `uint16_t` or `uint32_t`\n        (with machine dependent endianness and alignment)\n        UCS-2-INTERNAL, UCS-4-INTERNAL\n    Locale dependent, in terms of `char` or `wchar_t`\n        (with machine dependent endianness and alignment, and with OS and\n        locale dependent semantics)\n        char, wchar_t\n        The empty encoding name \"\" is equivalent to \"char\": it denotes the\n        locale dependent character encoding.\n\nIf you don't need the full gamut of encodings, consider using [iconv-lite][].\nIt supports most common encodings and doesn't require a compiler to install.\n\n## Installing with [npm](http://npmjs.org/)\n\n    $ npm install iconv\n\nNote that you do not need to have a copy of libiconv installed to use this\nmodule.\n\n## Compiling from source\n\n    $ git clone git://github.com/bnoordhuis/node-iconv.git\n    $ node-gyp configure build\n    $ npm install .\n\n## Usage\n\nEncode from one character encoding to another:\n\n    // convert from UTF-8 to ISO-8859-1\n    var Buffer = require('buffer').Buffer;\n    var Iconv  = require('iconv').Iconv;\n    var assert = require('assert');\n\n    var iconv = new Iconv('UTF-8', 'ISO-8859-1');\n    var buffer = iconv.convert('Hello, world!');\n    var buffer2 = iconv.convert(new Buffer('Hello, world!'));\n    assert.equals(buffer.inspect(), buffer2.inspect());\n    // do something useful with the buffers\n\nA simple ISO-8859-1 to UTF-8 conversion TCP service:\n\n    var net = require('net');\n    var Iconv = require('iconv').Iconv;\n    var server = net.createServer(function(conn) {\n      var iconv = new Iconv('latin1', 'utf-8');\n      conn.pipe(iconv).pipe(conn);\n    });\n    server.listen(8000);\n    console.log('Listening on tcp://0.0.0.0:8000/');\n\nLook at test/test-basic.js and test/test-stream.js for more examples\nand node-iconv's behaviour under error conditions.\n\n## Notes\n\nThings to keep in mind when you work with node-iconv.\n\n### Chunked data\n\nSay you are reading data in chunks from a HTTP stream. The logical input is a\nsingle document (the full POST request data) but the physical input will be\nspread over several buffers (the request chunks).\n\nYou must accumulate the small buffers into a single large buffer before\nperforming the conversion. If you don't, you will get unexpected results with\nmulti-byte and stateful character sets like UTF-8 and ISO-2022-JP.\n\nThe above only applies when you are calling `Iconv#convert()` yourself.\nIf you use the streaming interface, node-iconv takes care of stitching\npartial character sequences together again.\n\n### Dealing with untranslatable characters\n\nCharacters are not always translatable to another encoding. The UTF-8 string\n\"ça va が\", for example, cannot be represented in plain 7-bits ASCII without\nsome loss of fidelity.\n\nBy default, node-iconv throws EILSEQ when untranslatabe characters are\nencountered but this can be customized. Quoting the `iconv_open(3)` man page:\n\n    //TRANSLIT\n    When  the  string  \"//TRANSLIT\"  is appended to tocode, transliteration is\n    activated. This means that when a character cannot be represented in the\n    target character set, it can be approximated through one or several\n    similarly looking characters.\n\n    //IGNORE\n    When the string \"//IGNORE\" is appended to tocode, characters that cannot be\n    represented in the target character set will be silently discarded.\n\nExample usage:\n\n    var iconv = new Iconv('UTF-8', 'ASCII');\n    iconv.convert('ça va'); // throws EILSEQ\n\n    var iconv = new Iconv('UTF-8', 'ASCII//IGNORE');\n    iconv.convert('ça va'); // returns \"a va\"\n\n    var iconv = new Iconv('UTF-8', 'ASCII//TRANSLIT');\n    iconv.convert('ça va'); // \"ca va\"\n\n    var iconv = new Iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE');\n    iconv.convert('ça va が'); // \"ca va \"\n\n### EINVAL\n\nEINVAL is raised when the input ends in a partial character sequence. This is a\nfeature, not a bug.\n\n[iconv-lite]: https://www.npmjs.org/package/iconv-lite\n",
  "bugs": {
    "url": "https://github.com/bnoordhuis/node-iconv/issues"
  },
  "_id": "iconv@2.1.11",
  "_from": "iconv@~2.1.6"
}
